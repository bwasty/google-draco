/* automatically generated by rust-bindgen */

pub type string = [u64; 4usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct basic_string {
    pub _address: u8,
}
pub type basic_string__Char_alloc_type = u8;
pub type basic_string__Alloc_traits = u8;
pub type basic_string_traits_type = u8;
pub type basic_string_value_type = u8;
pub type basic_string_allocator_type = u8;
pub type basic_string_size_type = u8;
pub type basic_string_difference_type = u8;
pub type basic_string_reference = u8;
pub type basic_string_const_reference = u8;
pub type basic_string_pointer = u8;
pub type basic_string_const_pointer = u8;
pub type basic_string_iterator = u8;
pub type basic_string_const_iterator = u8;
pub type basic_string_const_reverse_iterator = u8;
pub type basic_string_reverse_iterator = u8;
pub type basic_string___const_iterator = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct basic_string__Alloc_hider {
    pub _address: u8,
}
pub const basic_string__S_local_capacity: basic_string__bindgen_ty_1 = 0;
pub type basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub union basic_string__bindgen_ty_2 {
    pub _bindgen_opaque_blob: u64,
}
impl Default for basic_string__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pair {
    pub _address: u8,
}
pub type pair_first_type = u8;
pub type pair_second_type = u8;
pub type pair__PCCP = u8;
pub type pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct allocator {
    pub _address: u8,
}
pub type allocator_size_type = u64;
pub type allocator_difference_type = u64;
pub type allocator_pointer = u8;
pub type allocator_const_pointer = u8;
pub type allocator_reference = u8;
pub type allocator_const_reference = u8;
pub type allocator_value_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct allocator_rebind {
    pub _address: u8,
}
pub type allocator_rebind_other = u8;
pub type allocator_propagate_on_container_move_assignment = u8;
pub type allocator_is_always_equal = u8;
pub type ostream = [u64; 34usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct equal_to {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct less {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct hash {
    pub _address: u8,
}
pub type array_value_type = u8;
pub type array_pointer = u8;
pub type array_const_pointer = u8;
pub type array_reference = u8;
pub type array_const_reference = u8;
pub type array_iterator = u8;
pub type array_const_iterator = u8;
pub type array_size_type = u64;
pub type array_difference_type = u64;
pub type array_reverse_iterator = u8;
pub type array_const_reverse_iterator = u8;
pub type array__AT_Type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct unique_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct unique_ptr__Pointer {
    pub _address: u8,
}
pub type unique_ptr__Pointer__Del = u8;
pub type unique_ptr__Pointer_type = u8;
pub type unique_ptr___tuple_type = u8;
pub type unique_ptr_pointer = u8;
pub type unique_ptr_element_type = u8;
pub type unique_ptr_deleter_type = u8;
pub type unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct map {
    pub _address: u8,
}
pub type map_key_type = u8;
pub type map_mapped_type = u8;
pub type map_value_type = u8;
pub type map_key_compare = u8;
pub type map_allocator_type = u8;
pub type map__Alloc_value_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct map_value_compare {
    pub _address: u8,
}
pub type map__Pair_alloc_type = u8;
pub type map__Rep_type = u8;
pub type map__Alloc_traits = u8;
pub type map_pointer = u8;
pub type map_const_pointer = u8;
pub type map_reference = u8;
pub type map_const_reference = u8;
pub type map_iterator = u8;
pub type map_const_iterator = u8;
pub type map_size_type = u8;
pub type map_difference_type = u8;
pub type map_reverse_iterator = u8;
pub type map_const_reverse_iterator = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vector {
    pub _address: u8,
}
pub type vector__Alloc_value_type = u8;
pub type vector__Base = u8;
pub type vector__Tp_alloc_type = u8;
pub type vector__Alloc_traits = u8;
pub type vector_value_type = u8;
pub type vector_pointer = u8;
pub type vector_const_pointer = u8;
pub type vector_reference = u8;
pub type vector_const_reference = u8;
pub type vector_iterator = u8;
pub type vector_const_iterator = u8;
pub type vector_const_reverse_iterator = u8;
pub type vector_reverse_iterator = u8;
pub type vector_size_type = u64;
pub type vector_difference_type = u64;
pub type vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct unordered_map {
    pub _address: u8,
}
pub type unordered_map__Hashtable = u8;
pub type unordered_map_key_type = u8;
pub type unordered_map_value_type = u8;
pub type unordered_map_mapped_type = u8;
pub type unordered_map_hasher = u8;
pub type unordered_map_key_equal = u8;
pub type unordered_map_allocator_type = u8;
pub type unordered_map_pointer = u8;
pub type unordered_map_const_pointer = u8;
pub type unordered_map_reference = u8;
pub type unordered_map_const_reference = u8;
pub type unordered_map_iterator = u8;
pub type unordered_map_const_iterator = u8;
pub type unordered_map_local_iterator = u8;
pub type unordered_map_const_local_iterator = u8;
pub type unordered_map_size_type = u8;
pub type unordered_map_difference_type = u8;
#[repr(C)]
#[derive(Debug)]
pub struct DecoderBuffer {
    pub data_: *const ::std::os::raw::c_char,
    pub data_size_: i64,
    pub pos_: i64,
    pub bit_decoder_: DecoderBuffer_BitDecoder,
    pub bit_mode_: bool,
    pub bitstream_version_: u16,
}
#[repr(C)]
#[derive(Debug)]
pub struct DecoderBuffer_BitDecoder {
    pub bit_buffer_: *const u8,
    pub bit_buffer_end_: *const u8,
    pub bit_offset_: usize,
}
#[test]
fn bindgen_test_layout_DecoderBuffer_BitDecoder() {
    assert_eq!(
        ::std::mem::size_of::<DecoderBuffer_BitDecoder>(),
        24usize,
        concat!("Size of: ", stringify!(DecoderBuffer_BitDecoder))
    );
    assert_eq!(
        ::std::mem::align_of::<DecoderBuffer_BitDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(DecoderBuffer_BitDecoder))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DecoderBuffer_BitDecoder>())).bit_buffer_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer_BitDecoder),
            "::",
            stringify!(bit_buffer_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DecoderBuffer_BitDecoder>())).bit_buffer_end_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer_BitDecoder),
            "::",
            stringify!(bit_buffer_end_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DecoderBuffer_BitDecoder>())).bit_offset_ as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer_BitDecoder),
            "::",
            stringify!(bit_offset_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer10BitDecoderC1Ev"]
    pub fn DecoderBuffer_BitDecoder_BitDecoder(this: *mut DecoderBuffer_BitDecoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer10BitDecoderD1Ev"]
    pub fn DecoderBuffer_BitDecoder_BitDecoder_destructor(this: *mut DecoderBuffer_BitDecoder);
}
impl Default for DecoderBuffer_BitDecoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl DecoderBuffer_BitDecoder {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        DecoderBuffer_BitDecoder_BitDecoder(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        DecoderBuffer_BitDecoder_BitDecoder_destructor(self)
    }
}
#[test]
fn bindgen_test_layout_DecoderBuffer() {
    assert_eq!(
        ::std::mem::size_of::<DecoderBuffer>(),
        56usize,
        concat!("Size of: ", stringify!(DecoderBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<DecoderBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(DecoderBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DecoderBuffer>())).data_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer),
            "::",
            stringify!(data_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DecoderBuffer>())).data_size_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer),
            "::",
            stringify!(data_size_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DecoderBuffer>())).pos_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer),
            "::",
            stringify!(pos_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DecoderBuffer>())).bit_decoder_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer),
            "::",
            stringify!(bit_decoder_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DecoderBuffer>())).bit_mode_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer),
            "::",
            stringify!(bit_mode_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DecoderBuffer>())).bitstream_version_ as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(DecoderBuffer),
            "::",
            stringify!(bitstream_version_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer4InitEPKcm"]
    pub fn DecoderBuffer_Init(
        this: *mut DecoderBuffer,
        data: *const ::std::os::raw::c_char,
        data_size: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer4InitEPKcmt"]
    pub fn DecoderBuffer_Init1(
        this: *mut DecoderBuffer,
        data: *const ::std::os::raw::c_char,
        data_size: usize,
        version: u16,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer16StartBitDecodingEbPm"]
    pub fn DecoderBuffer_StartBitDecoding(
        this: *mut DecoderBuffer,
        decode_size: bool,
        out_size: *mut u64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBuffer14EndBitDecodingEv"]
    pub fn DecoderBuffer_EndBitDecoding(this: *mut DecoderBuffer);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco13DecoderBufferC1Ev"]
    pub fn DecoderBuffer_DecoderBuffer(this: *mut DecoderBuffer);
}
impl Default for DecoderBuffer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl DecoderBuffer {
    #[inline]
    pub unsafe fn Init(&mut self, data: *const ::std::os::raw::c_char, data_size: usize) {
        DecoderBuffer_Init(self, data, data_size)
    }
    #[inline]
    pub unsafe fn Init1(
        &mut self,
        data: *const ::std::os::raw::c_char,
        data_size: usize,
        version: u16,
    ) {
        DecoderBuffer_Init1(self, data, data_size, version)
    }
    #[inline]
    pub unsafe fn StartBitDecoding(&mut self, decode_size: bool, out_size: *mut u64) -> bool {
        DecoderBuffer_StartBitDecoding(self, decode_size, out_size)
    }
    #[inline]
    pub unsafe fn EndBitDecoding(&mut self) {
        DecoderBuffer_EndBitDecoding(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        DecoderBuffer_DecoderBuffer(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
pub const EncodedGeometryType_INVALID_GEOMETRY_TYPE: EncodedGeometryType = -1;
pub const EncodedGeometryType_POINT_CLOUD: EncodedGeometryType = 0;
pub const EncodedGeometryType_TRIANGULAR_MESH: EncodedGeometryType = 1;
pub type EncodedGeometryType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexType<ValueTypeT> {
    pub value_: ValueTypeT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueTypeT>>,
}
pub type IndexType_ThisIndexType<ValueTypeT> = IndexType<ValueTypeT>;
pub type IndexType_ValueType<ValueTypeT> = ValueTypeT;
impl<ValueTypeT> Default for IndexType<ValueTypeT> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttributeValueIndex_tag_type_ {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_AttributeValueIndex_tag_type_() {
    assert_eq!(
        ::std::mem::size_of::<AttributeValueIndex_tag_type_>(),
        1usize,
        concat!("Size of: ", stringify!(AttributeValueIndex_tag_type_))
    );
    assert_eq!(
        ::std::mem::align_of::<AttributeValueIndex_tag_type_>(),
        1usize,
        concat!("Alignment of ", stringify!(AttributeValueIndex_tag_type_))
    );
}
pub type AttributeValueIndex = IndexType<::std::os::raw::c_uint>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PointIndex_tag_type_ {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_PointIndex_tag_type_() {
    assert_eq!(
        ::std::mem::size_of::<PointIndex_tag_type_>(),
        1usize,
        concat!("Size of: ", stringify!(PointIndex_tag_type_))
    );
    assert_eq!(
        ::std::mem::align_of::<PointIndex_tag_type_>(),
        1usize,
        concat!("Alignment of ", stringify!(PointIndex_tag_type_))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FaceIndex_tag_type_ {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_FaceIndex_tag_type_() {
    assert_eq!(
        ::std::mem::size_of::<FaceIndex_tag_type_>(),
        1usize,
        concat!("Size of: ", stringify!(FaceIndex_tag_type_))
    );
    assert_eq!(
        ::std::mem::align_of::<FaceIndex_tag_type_>(),
        1usize,
        concat!("Alignment of ", stringify!(FaceIndex_tag_type_))
    );
}
pub const DataType_DT_INVALID: DataType = 0;
pub const DataType_DT_INT8: DataType = 1;
pub const DataType_DT_UINT8: DataType = 2;
pub const DataType_DT_INT16: DataType = 3;
pub const DataType_DT_UINT16: DataType = 4;
pub const DataType_DT_INT32: DataType = 5;
pub const DataType_DT_UINT32: DataType = 6;
pub const DataType_DT_INT64: DataType = 7;
pub const DataType_DT_UINT64: DataType = 8;
pub const DataType_DT_FLOAT32: DataType = 9;
pub const DataType_DT_FLOAT64: DataType = 10;
pub const DataType_DT_BOOL: DataType = 11;
pub const DataType_DT_TYPES_COUNT: DataType = 12;
pub type DataType = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DataBufferDescriptor {
    pub buffer_id: i64,
    pub buffer_update_count: i64,
}
#[test]
fn bindgen_test_layout_DataBufferDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<DataBufferDescriptor>(),
        16usize,
        concat!("Size of: ", stringify!(DataBufferDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<DataBufferDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(DataBufferDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DataBufferDescriptor>())).buffer_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DataBufferDescriptor),
            "::",
            stringify!(buffer_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DataBufferDescriptor>())).buffer_update_count as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DataBufferDescriptor),
            "::",
            stringify!(buffer_update_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct DataBuffer {
    pub data_: [u64; 3usize],
    pub descriptor_: DataBufferDescriptor,
}
#[test]
fn bindgen_test_layout_DataBuffer() {
    assert_eq!(
        ::std::mem::size_of::<DataBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(DataBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<DataBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(DataBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DataBuffer>())).data_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DataBuffer),
            "::",
            stringify!(data_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DataBuffer>())).descriptor_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DataBuffer),
            "::",
            stringify!(descriptor_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer6UpdateEPKvl"]
    pub fn DataBuffer_Update(
        this: *mut DataBuffer,
        data: *const ::std::os::raw::c_void,
        size: i64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer6UpdateEPKvll"]
    pub fn DataBuffer_Update1(
        this: *mut DataBuffer,
        data: *const ::std::os::raw::c_void,
        size: i64,
        offset: i64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer6ResizeEl"]
    pub fn DataBuffer_Resize(this: *mut DataBuffer, new_size: i64);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBuffer17WriteDataToStreamERSo"]
    pub fn DataBuffer_WriteDataToStream(this: *mut DataBuffer, stream: *mut ostream);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10DataBufferC1Ev"]
    pub fn DataBuffer_DataBuffer(this: *mut DataBuffer);
}
impl DataBuffer {
    #[inline]
    pub unsafe fn Update(&mut self, data: *const ::std::os::raw::c_void, size: i64) -> bool {
        DataBuffer_Update(self, data, size)
    }
    #[inline]
    pub unsafe fn Update1(
        &mut self,
        data: *const ::std::os::raw::c_void,
        size: i64,
        offset: i64,
    ) -> bool {
        DataBuffer_Update1(self, data, size, offset)
    }
    #[inline]
    pub unsafe fn Resize(&mut self, new_size: i64) {
        DataBuffer_Resize(self, new_size)
    }
    #[inline]
    pub unsafe fn WriteDataToStream(&mut self, stream: *mut ostream) {
        DataBuffer_WriteDataToStream(self, stream)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        DataBuffer_DataBuffer(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GeometryAttribute {
    pub buffer_: *mut DataBuffer,
    pub buffer_descriptor_: DataBufferDescriptor,
    pub num_components_: i8,
    pub data_type_: DataType,
    pub normalized_: bool,
    pub byte_stride_: i64,
    pub byte_offset_: i64,
    pub attribute_type_: GeometryAttribute_Type,
    pub unique_id_: u32,
}
pub const GeometryAttribute_Type_INVALID: GeometryAttribute_Type = -1;
pub const GeometryAttribute_Type_POSITION: GeometryAttribute_Type = 0;
pub const GeometryAttribute_Type_NORMAL: GeometryAttribute_Type = 1;
pub const GeometryAttribute_Type_COLOR: GeometryAttribute_Type = 2;
pub const GeometryAttribute_Type_TEX_COORD: GeometryAttribute_Type = 3;
pub const GeometryAttribute_Type_GENERIC: GeometryAttribute_Type = 4;
pub const GeometryAttribute_Type_NAMED_ATTRIBUTES_COUNT: GeometryAttribute_Type = 5;
pub type GeometryAttribute_Type = i32;
#[test]
fn bindgen_test_layout_GeometryAttribute() {
    assert_eq!(
        ::std::mem::size_of::<GeometryAttribute>(),
        64usize,
        concat!("Size of: ", stringify!(GeometryAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<GeometryAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(GeometryAttribute))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeometryAttribute>())).buffer_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(buffer_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GeometryAttribute>())).buffer_descriptor_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(buffer_descriptor_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GeometryAttribute>())).num_components_ as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(num_components_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeometryAttribute>())).data_type_ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(data_type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeometryAttribute>())).normalized_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(normalized_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeometryAttribute>())).byte_stride_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(byte_stride_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeometryAttribute>())).byte_offset_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(byte_offset_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GeometryAttribute>())).attribute_type_ as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(attribute_type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeometryAttribute>())).unique_id_ as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryAttribute),
            "::",
            stringify!(unique_id_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute4InitENS0_4TypeEPNS_10DataBufferEaNS_8DataTypeEbll"]
    pub fn GeometryAttribute_Init(
        this: *mut GeometryAttribute,
        attribute_type: GeometryAttribute_Type,
        buffer: *mut DataBuffer,
        num_components: i8,
        data_type: DataType,
        normalized: bool,
        byte_stride: i64,
        byte_offset: i64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute8CopyFromERKS0_"]
    pub fn GeometryAttribute_CopyFrom(
        this: *mut GeometryAttribute,
        src_att: *const GeometryAttribute,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttribute11ResetBufferEPNS_10DataBufferEll"]
    pub fn GeometryAttribute_ResetBuffer(
        this: *mut GeometryAttribute,
        buffer: *mut DataBuffer,
        byte_stride: i64,
        byte_offset: i64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco17GeometryAttributeC1Ev"]
    pub fn GeometryAttribute_GeometryAttribute(this: *mut GeometryAttribute);
}
impl Default for GeometryAttribute {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl GeometryAttribute {
    #[inline]
    pub unsafe fn Init(
        &mut self,
        attribute_type: GeometryAttribute_Type,
        buffer: *mut DataBuffer,
        num_components: i8,
        data_type: DataType,
        normalized: bool,
        byte_stride: i64,
        byte_offset: i64,
    ) {
        GeometryAttribute_Init(
            self,
            attribute_type,
            buffer,
            num_components,
            data_type,
            normalized,
            byte_stride,
            byte_offset,
        )
    }
    #[inline]
    pub unsafe fn CopyFrom(&mut self, src_att: *const GeometryAttribute) -> bool {
        GeometryAttribute_CopyFrom(self, src_att)
    }
    #[inline]
    pub unsafe fn ResetBuffer(
        &mut self,
        buffer: *mut DataBuffer,
        byte_stride: i64,
        byte_offset: i64,
    ) {
        GeometryAttribute_ResetBuffer(self, buffer, byte_stride, byte_offset)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        GeometryAttribute_GeometryAttribute(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct Options {
    pub options_: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_Options() {
    assert_eq!(
        ::std::mem::size_of::<Options>(),
        48usize,
        concat!("Size of: ", stringify!(Options))
    );
    assert_eq!(
        ::std::mem::align_of::<Options>(),
        8usize,
        concat!("Alignment of ", stringify!(Options))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Options>())).options_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Options),
            "::",
            stringify!(options_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options15MergeAndReplaceERKS0_"]
    pub fn Options_MergeAndReplace(this: *mut Options, other_options: *const Options);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options6SetIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn Options_SetInt(this: *mut Options, name: *const string, val: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options8SetFloatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEf"]
    pub fn Options_SetFloat(this: *mut Options, name: *const string, val: f32);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options7SetBoolERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
    pub fn Options_SetBool(this: *mut Options, name: *const string, val: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Options9SetStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn Options_SetString(this: *mut Options, name: *const string, val: *const string);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options6GetIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_GetInt(this: *const Options, name: *const string) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options6GetIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn Options_GetInt1(
        this: *const Options,
        name: *const string,
        default_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options8GetFloatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_GetFloat(this: *const Options, name: *const string) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options8GetFloatERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEf"]
    pub fn Options_GetFloat1(this: *const Options, name: *const string, default_val: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options7GetBoolERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_GetBool(this: *const Options, name: *const string) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options7GetBoolERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb"]
    pub fn Options_GetBool1(this: *const Options, name: *const string, default_val: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options9GetStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Options_GetString(this: *const Options, name: *const string) -> string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco7Options9GetStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn Options_GetString1(
        this: *const Options,
        name: *const string,
        default_val: *const string,
    ) -> string;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7OptionsC1Ev"]
    pub fn Options_Options(this: *mut Options);
}
impl Options {
    #[inline]
    pub unsafe fn MergeAndReplace(&mut self, other_options: *const Options) {
        Options_MergeAndReplace(self, other_options)
    }
    #[inline]
    pub unsafe fn SetInt(&mut self, name: *const string, val: ::std::os::raw::c_int) {
        Options_SetInt(self, name, val)
    }
    #[inline]
    pub unsafe fn SetFloat(&mut self, name: *const string, val: f32) {
        Options_SetFloat(self, name, val)
    }
    #[inline]
    pub unsafe fn SetBool(&mut self, name: *const string, val: bool) {
        Options_SetBool(self, name, val)
    }
    #[inline]
    pub unsafe fn SetString(&mut self, name: *const string, val: *const string) {
        Options_SetString(self, name, val)
    }
    #[inline]
    pub unsafe fn GetInt(&self, name: *const string) -> ::std::os::raw::c_int {
        Options_GetInt(self, name)
    }
    #[inline]
    pub unsafe fn GetInt1(
        &self,
        name: *const string,
        default_val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Options_GetInt1(self, name, default_val)
    }
    #[inline]
    pub unsafe fn GetFloat(&self, name: *const string) -> f32 {
        Options_GetFloat(self, name)
    }
    #[inline]
    pub unsafe fn GetFloat1(&self, name: *const string, default_val: f32) -> f32 {
        Options_GetFloat1(self, name, default_val)
    }
    #[inline]
    pub unsafe fn GetBool(&self, name: *const string) -> bool {
        Options_GetBool(self, name)
    }
    #[inline]
    pub unsafe fn GetBool1(&self, name: *const string, default_val: bool) -> bool {
        Options_GetBool1(self, name, default_val)
    }
    #[inline]
    pub unsafe fn GetString(&self, name: *const string) -> string {
        Options_GetString(self, name)
    }
    #[inline]
    pub unsafe fn GetString1(&self, name: *const string, default_val: *const string) -> string {
        Options_GetString1(self, name, default_val)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Options_Options(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct DracoOptions {
    pub global_options_: Options,
    pub attribute_options_: u8,
}
pub type DracoOptions_AttributeKey<AttributeKeyT> = AttributeKeyT;
pub type DecoderOptions = DracoOptions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Status {
    pub code_: Status_Code,
    pub error_msg_: string,
}
pub const Status_Code_OK: Status_Code = 0;
pub const Status_Code_DRACO_ERROR: Status_Code = -1;
pub const Status_Code_IO_ERROR: Status_Code = -2;
pub const Status_Code_INVALID_PARAMETER: Status_Code = -3;
pub const Status_Code_UNSUPPORTED_VERSION: Status_Code = -4;
pub const Status_Code_UNKNOWN_VERSION: Status_Code = -5;
pub type Status_Code = i32;
#[test]
fn bindgen_test_layout_Status() {
    assert_eq!(
        ::std::mem::size_of::<Status>(),
        40usize,
        concat!("Size of: ", stringify!(Status))
    );
    assert_eq!(
        ::std::mem::align_of::<Status>(),
        8usize,
        concat!("Alignment of ", stringify!(Status))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Status>())).code_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Status),
            "::",
            stringify!(code_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Status>())).error_msg_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Status),
            "::",
            stringify!(error_msg_)
        )
    );
}
impl Default for Status {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatusOr<T> {
    pub status_: Status,
    pub value_: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
impl<T> Default for StatusOr<T> {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM: AttributeTransformType = -1;
pub const AttributeTransformType_ATTRIBUTE_NO_TRANSFORM: AttributeTransformType = 0;
pub const AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM: AttributeTransformType = 1;
pub const AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM: AttributeTransformType = 2;
pub type AttributeTransformType = i32;
#[repr(C)]
#[derive(Debug)]
pub struct AttributeTransformData {
    pub transform_type_: AttributeTransformType,
    pub buffer_: DataBuffer,
}
#[test]
fn bindgen_test_layout_AttributeTransformData() {
    assert_eq!(
        ::std::mem::size_of::<AttributeTransformData>(),
        48usize,
        concat!("Size of: ", stringify!(AttributeTransformData))
    );
    assert_eq!(
        ::std::mem::align_of::<AttributeTransformData>(),
        8usize,
        concat!("Alignment of ", stringify!(AttributeTransformData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AttributeTransformData>())).transform_type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeTransformData),
            "::",
            stringify!(transform_type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AttributeTransformData>())).buffer_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeTransformData),
            "::",
            stringify!(buffer_)
        )
    );
}
impl Default for AttributeTransformData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct IndexTypeVector {
    pub vector_: u8,
}
pub type IndexTypeVector_const_reference = u8;
pub type IndexTypeVector_reference = u8;
#[repr(C)]
#[derive(Debug)]
pub struct PointAttribute {
    pub _base: GeometryAttribute,
    pub attribute_buffer_: u64,
    pub indices_map_: IndexTypeVector,
    pub num_unique_entries_: ValueType,
    pub identity_mapping_: bool,
    pub attribute_transform_data_: u64,
}
#[test]
fn bindgen_test_layout_PointAttribute() {
    assert_eq!(
        ::std::mem::size_of::<PointAttribute>(),
        112usize,
        concat!("Size of: ", stringify!(PointAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<PointAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(PointAttribute))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PointAttribute>())).attribute_buffer_ as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PointAttribute),
            "::",
            stringify!(attribute_buffer_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PointAttribute>())).indices_map_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PointAttribute),
            "::",
            stringify!(indices_map_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PointAttribute>())).num_unique_entries_ as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PointAttribute),
            "::",
            stringify!(num_unique_entries_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PointAttribute>())).identity_mapping_ as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(PointAttribute),
            "::",
            stringify!(identity_mapping_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PointAttribute>())).attribute_transform_data_ as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(PointAttribute),
            "::",
            stringify!(attribute_transform_data_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco14PointAttribute8CopyFromERKS0_"]
    pub fn PointAttribute_CopyFrom(this: *mut PointAttribute, src_att: *const PointAttribute);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco14PointAttribute5ResetEm"]
    pub fn PointAttribute_Reset(this: *mut PointAttribute, num_attribute_values: usize) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco14PointAttribute17DeduplicateValuesERKNS_17GeometryAttributeE"]
    pub fn PointAttribute_DeduplicateValues(
        this: *mut PointAttribute,
        in_att: *const GeometryAttribute,
    ) -> ValueType;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco14PointAttribute17DeduplicateValuesERKNS_17GeometryAttributeENS_9IndexTypeIjNS_29AttributeValueIndex_tag_type_EEE"]
    pub fn PointAttribute_DeduplicateValues1(
        this: *mut PointAttribute,
        in_att: *const GeometryAttribute,
        in_att_offset: AttributeValueIndex,
    ) -> ValueType;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco14PointAttributeC1Ev"]
    pub fn PointAttribute_PointAttribute(this: *mut PointAttribute);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco14PointAttributeC1ERKNS_17GeometryAttributeE"]
    pub fn PointAttribute_PointAttribute1(this: *mut PointAttribute, att: *const GeometryAttribute);
}
impl Default for PointAttribute {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl PointAttribute {
    #[inline]
    pub unsafe fn CopyFrom(&mut self, src_att: *const PointAttribute) {
        PointAttribute_CopyFrom(self, src_att)
    }
    #[inline]
    pub unsafe fn Reset(&mut self, num_attribute_values: usize) -> bool {
        PointAttribute_Reset(self, num_attribute_values)
    }
    #[inline]
    pub unsafe fn DeduplicateValues(&mut self, in_att: *const GeometryAttribute) -> ValueType {
        PointAttribute_DeduplicateValues(self, in_att)
    }
    #[inline]
    pub unsafe fn DeduplicateValues1(
        &mut self,
        in_att: *const GeometryAttribute,
        in_att_offset: AttributeValueIndex,
    ) -> ValueType {
        PointAttribute_DeduplicateValues1(self, in_att, in_att_offset)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        PointAttribute_PointAttribute(&mut __bindgen_tmp);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(att: *const GeometryAttribute) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        PointAttribute_PointAttribute1(&mut __bindgen_tmp, att);
        __bindgen_tmp
    }
}
pub type VectorD_Scalar<ScalarT> = ScalarT;
pub type VectorD_Self = u8;
pub type VectorD_CoefficientType<ScalarT> = ScalarT;
pub type Vector3f = [u32; 3usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BoundingBox {
    pub min_point_: Vector3f,
    pub max_point_: Vector3f,
}
#[test]
fn bindgen_test_layout_BoundingBox() {
    assert_eq!(
        ::std::mem::size_of::<BoundingBox>(),
        24usize,
        concat!("Size of: ", stringify!(BoundingBox))
    );
    assert_eq!(
        ::std::mem::align_of::<BoundingBox>(),
        4usize,
        concat!("Alignment of ", stringify!(BoundingBox))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoundingBox>())).min_point_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BoundingBox),
            "::",
            stringify!(min_point_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BoundingBox>())).max_point_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BoundingBox),
            "::",
            stringify!(max_point_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco11BoundingBoxC1ERKNS_7VectorDIfLi3EEES4_"]
    pub fn BoundingBox_BoundingBox(
        this: *mut BoundingBox,
        min_point_in: *const Vector3f,
        max_point_in: *const Vector3f,
    );
}
impl BoundingBox {
    #[inline]
    pub unsafe fn new(min_point_in: *const Vector3f, max_point_in: *const Vector3f) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        BoundingBox_BoundingBox(&mut __bindgen_tmp, min_point_in, max_point_in);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct EntryValue {
    pub data_: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_EntryValue() {
    assert_eq!(
        ::std::mem::size_of::<EntryValue>(),
        24usize,
        concat!("Size of: ", stringify!(EntryValue))
    );
    assert_eq!(
        ::std::mem::align_of::<EntryValue>(),
        8usize,
        concat!("Alignment of ", stringify!(EntryValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EntryValue>())).data_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EntryValue),
            "::",
            stringify!(data_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10EntryValueC1ERKS0_"]
    pub fn EntryValue_EntryValue(this: *mut EntryValue, value: *const EntryValue);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10EntryValueC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn EntryValue_EntryValue1(this: *mut EntryValue, value: *const string);
}
impl EntryValue {
    #[inline]
    pub unsafe fn new(value: *const EntryValue) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        EntryValue_EntryValue(&mut __bindgen_tmp, value);
        __bindgen_tmp
    }
    #[inline]
    pub unsafe fn new1(value: *const string) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        EntryValue_EntryValue1(&mut __bindgen_tmp, value);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct Metadata {
    pub entries_: [u64; 7usize],
    pub sub_metadatas_: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_Metadata() {
    assert_eq!(
        ::std::mem::size_of::<Metadata>(),
        112usize,
        concat!("Size of: ", stringify!(Metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<Metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(Metadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Metadata>())).entries_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Metadata),
            "::",
            stringify!(entries_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Metadata>())).sub_metadatas_ as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Metadata),
            "::",
            stringify!(sub_metadatas_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata11AddEntryIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
    pub fn Metadata_AddEntryInt(this: *mut Metadata, name: *const string, value: i32);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata11GetEntryIntERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPi"]
    pub fn Metadata_GetEntryInt(
        this: *const Metadata,
        name: *const string,
        value: *mut i32,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata16AddEntryIntArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorIiSaIiEE"]
    pub fn Metadata_AddEntryIntArray(
        this: *mut Metadata,
        name: *const string,
        value: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata16GetEntryIntArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPSt6vectorIiSaIiEE"]
    pub fn Metadata_GetEntryIntArray(
        this: *const Metadata,
        name: *const string,
        value: *mut [u64; 3usize],
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata14AddEntryDoubleERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEd"]
    pub fn Metadata_AddEntryDouble(this: *mut Metadata, name: *const string, value: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata14GetEntryDoubleERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPd"]
    pub fn Metadata_GetEntryDouble(
        this: *const Metadata,
        name: *const string,
        value: *mut f64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata19AddEntryDoubleArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorIdSaIdEE"]
    pub fn Metadata_AddEntryDoubleArray(this: *mut Metadata, name: *const string, value: *const u8);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata19GetEntryDoubleArrayERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPSt6vectorIdSaIdEE"]
    pub fn Metadata_GetEntryDoubleArray(
        this: *const Metadata,
        name: *const string,
        value: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata14AddEntryStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn Metadata_AddEntryString(this: *mut Metadata, name: *const string, value: *const string);
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata14GetEntryStringERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPS6_"]
    pub fn Metadata_GetEntryString(
        this: *const Metadata,
        name: *const string,
        value: *mut string,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata14AddEntryBinaryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorIhSaIhEE"]
    pub fn Metadata_AddEntryBinary(
        this: *mut Metadata,
        name: *const string,
        value: *const [u64; 3usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata14GetEntryBinaryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPSt6vectorIhSaIhEE"]
    pub fn Metadata_GetEntryBinary(
        this: *const Metadata,
        name: *const string,
        value: *mut [u64; 3usize],
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata14AddSubMetadataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt10unique_ptrIS0_St14default_deleteIS0_EE"]
    pub fn Metadata_AddSubMetadata(
        this: *mut Metadata,
        name: *const string,
        sub_metadata: u64,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco8Metadata14GetSubMetadataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Metadata_GetSubMetadata(this: *const Metadata, name: *const string) -> *const Metadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8Metadata11RemoveEntryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn Metadata_RemoveEntry(this: *mut Metadata, name: *const string);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco8MetadataC1ERKS0_"]
    pub fn Metadata_Metadata(this: *mut Metadata, metadata: *const Metadata);
}
impl Metadata {
    #[inline]
    pub unsafe fn AddEntryInt(&mut self, name: *const string, value: i32) {
        Metadata_AddEntryInt(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryInt(&self, name: *const string, value: *mut i32) -> bool {
        Metadata_GetEntryInt(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryIntArray(&mut self, name: *const string, value: *const [u64; 3usize]) {
        Metadata_AddEntryIntArray(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryIntArray(&self, name: *const string, value: *mut [u64; 3usize]) -> bool {
        Metadata_GetEntryIntArray(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryDouble(&mut self, name: *const string, value: f64) {
        Metadata_AddEntryDouble(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryDouble(&self, name: *const string, value: *mut f64) -> bool {
        Metadata_GetEntryDouble(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryDoubleArray(&mut self, name: *const string, value: *const u8) {
        Metadata_AddEntryDoubleArray(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryDoubleArray(&self, name: *const string, value: *mut u8) -> bool {
        Metadata_GetEntryDoubleArray(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryString(&mut self, name: *const string, value: *const string) {
        Metadata_AddEntryString(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryString(&self, name: *const string, value: *mut string) -> bool {
        Metadata_GetEntryString(self, name, value)
    }
    #[inline]
    pub unsafe fn AddEntryBinary(&mut self, name: *const string, value: *const [u64; 3usize]) {
        Metadata_AddEntryBinary(self, name, value)
    }
    #[inline]
    pub unsafe fn GetEntryBinary(&self, name: *const string, value: *mut [u64; 3usize]) -> bool {
        Metadata_GetEntryBinary(self, name, value)
    }
    #[inline]
    pub unsafe fn AddSubMetadata(&mut self, name: *const string, sub_metadata: u64) -> bool {
        Metadata_AddSubMetadata(self, name, sub_metadata)
    }
    #[inline]
    pub unsafe fn GetSubMetadata(&self, name: *const string) -> *const Metadata {
        Metadata_GetSubMetadata(self, name)
    }
    #[inline]
    pub unsafe fn RemoveEntry(&mut self, name: *const string) {
        Metadata_RemoveEntry(self, name)
    }
    #[inline]
    pub unsafe fn new(metadata: *const Metadata) -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Metadata_Metadata(&mut __bindgen_tmp, metadata);
        __bindgen_tmp
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct AttributeMetadata {
    pub _base: Metadata,
    pub att_unique_id_: u32,
}
#[test]
fn bindgen_test_layout_AttributeMetadata() {
    assert_eq!(
        ::std::mem::size_of::<AttributeMetadata>(),
        120usize,
        concat!("Size of: ", stringify!(AttributeMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<AttributeMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(AttributeMetadata))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AttributeMetadata>())).att_unique_id_ as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AttributeMetadata),
            "::",
            stringify!(att_unique_id_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct GeometryMetadata {
    pub _base: Metadata,
    pub att_metadatas_: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_GeometryMetadata() {
    assert_eq!(
        ::std::mem::size_of::<GeometryMetadata>(),
        136usize,
        concat!("Size of: ", stringify!(GeometryMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<GeometryMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(GeometryMetadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GeometryMetadata>())).att_metadatas_ as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(GeometryMetadata),
            "::",
            stringify!(att_metadatas_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco16GeometryMetadata33GetAttributeMetadataByStringEntryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_"]
    pub fn GeometryMetadata_GetAttributeMetadataByStringEntry(
        this: *const GeometryMetadata,
        entry_name: *const string,
        entry_value: *const string,
    ) -> *const AttributeMetadata;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco16GeometryMetadata20AddAttributeMetadataESt10unique_ptrINS_17AttributeMetadataESt14default_deleteIS2_EE"]
    pub fn GeometryMetadata_AddAttributeMetadata(
        this: *mut GeometryMetadata,
        att_metadata: u64,
    ) -> bool;
}
impl GeometryMetadata {
    #[inline]
    pub unsafe fn GetAttributeMetadataByStringEntry(
        &self,
        entry_name: *const string,
        entry_value: *const string,
    ) -> *const AttributeMetadata {
        GeometryMetadata_GetAttributeMetadataByStringEntry(self, entry_name, entry_value)
    }
    #[inline]
    pub unsafe fn AddAttributeMetadata(&mut self, att_metadata: u64) -> bool {
        GeometryMetadata_AddAttributeMetadata(self, att_metadata)
    }
}
#[repr(C)]
pub struct PointCloud__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct PointCloud {
    pub vtable_: *const PointCloud__bindgen_vtable,
    pub metadata_: u64,
    pub attributes_: [u64; 3usize],
    pub named_attribute_index_: [u64; 15usize],
    pub num_points_: ValueType,
}
#[test]
fn bindgen_test_layout_PointCloud() {
    assert_eq!(
        ::std::mem::size_of::<PointCloud>(),
        168usize,
        concat!("Size of: ", stringify!(PointCloud))
    );
    assert_eq!(
        ::std::mem::align_of::<PointCloud>(),
        8usize,
        concat!("Alignment of ", stringify!(PointCloud))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PointCloud>())).metadata_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PointCloud),
            "::",
            stringify!(metadata_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PointCloud>())).attributes_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PointCloud),
            "::",
            stringify!(attributes_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PointCloud>())).named_attribute_index_ as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PointCloud),
            "::",
            stringify!(named_attribute_index_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PointCloud>())).num_points_ as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(PointCloud),
            "::",
            stringify!(num_points_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud18NumNamedAttributesENS_17GeometryAttribute4TypeE"]
    pub fn PointCloud_NumNamedAttributes(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
    ) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud19GetNamedAttributeIdENS_17GeometryAttribute4TypeE"]
    pub fn PointCloud_GetNamedAttributeId(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
    ) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud19GetNamedAttributeIdENS_17GeometryAttribute4TypeEi"]
    pub fn PointCloud_GetNamedAttributeId1(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
        i: ::std::os::raw::c_int,
    ) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud17GetNamedAttributeENS_17GeometryAttribute4TypeE"]
    pub fn PointCloud_GetNamedAttribute(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
    ) -> *const PointAttribute;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud17GetNamedAttributeENS_17GeometryAttribute4TypeEi"]
    pub fn PointCloud_GetNamedAttribute1(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
        i: ::std::os::raw::c_int,
    ) -> *const PointAttribute;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud27GetNamedAttributeByUniqueIdENS_17GeometryAttribute4TypeEj"]
    pub fn PointCloud_GetNamedAttributeByUniqueId(
        this: *const PointCloud,
        type_: GeometryAttribute_Type,
        id: u32,
    ) -> *const PointAttribute;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud22GetAttributeByUniqueIdEj"]
    pub fn PointCloud_GetAttributeByUniqueId(
        this: *const PointCloud,
        id: u32,
    ) -> *const PointAttribute;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud24GetAttributeIdByUniqueIdEj"]
    pub fn PointCloud_GetAttributeIdByUniqueId(this: *const PointCloud, unique_id: u32) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloud12AddAttributeESt10unique_ptrINS_14PointAttributeESt14default_deleteIS2_EE"]
    pub fn PointCloud_AddAttribute(this: *mut PointCloud, pa: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloud12AddAttributeERKNS_17GeometryAttributeEbj"]
    pub fn PointCloud_AddAttribute1(
        this: *mut PointCloud,
        att: *const GeometryAttribute,
        identity_mapping: bool,
        num_attribute_values: ValueType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud15CreateAttributeERKNS_17GeometryAttributeEbj"]
    pub fn PointCloud_CreateAttribute(
        this: *const PointCloud,
        att: *const GeometryAttribute,
        identity_mapping: bool,
        num_attribute_values: ValueType,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZNK5draco10PointCloud18ComputeBoundingBoxEv"]
    pub fn PointCloud_ComputeBoundingBox(this: *const PointCloud) -> BoundingBox;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloudC1Ev"]
    pub fn PointCloud_PointCloud(this: *mut PointCloud);
}
impl Default for PointCloud {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl PointCloud {
    #[inline]
    pub unsafe fn NumNamedAttributes(&self, type_: GeometryAttribute_Type) -> i32 {
        PointCloud_NumNamedAttributes(self, type_)
    }
    #[inline]
    pub unsafe fn GetNamedAttributeId(&self, type_: GeometryAttribute_Type) -> i32 {
        PointCloud_GetNamedAttributeId(self, type_)
    }
    #[inline]
    pub unsafe fn GetNamedAttributeId1(
        &self,
        type_: GeometryAttribute_Type,
        i: ::std::os::raw::c_int,
    ) -> i32 {
        PointCloud_GetNamedAttributeId1(self, type_, i)
    }
    #[inline]
    pub unsafe fn GetNamedAttribute(&self, type_: GeometryAttribute_Type) -> *const PointAttribute {
        PointCloud_GetNamedAttribute(self, type_)
    }
    #[inline]
    pub unsafe fn GetNamedAttribute1(
        &self,
        type_: GeometryAttribute_Type,
        i: ::std::os::raw::c_int,
    ) -> *const PointAttribute {
        PointCloud_GetNamedAttribute1(self, type_, i)
    }
    #[inline]
    pub unsafe fn GetNamedAttributeByUniqueId(
        &self,
        type_: GeometryAttribute_Type,
        id: u32,
    ) -> *const PointAttribute {
        PointCloud_GetNamedAttributeByUniqueId(self, type_, id)
    }
    #[inline]
    pub unsafe fn GetAttributeByUniqueId(&self, id: u32) -> *const PointAttribute {
        PointCloud_GetAttributeByUniqueId(self, id)
    }
    #[inline]
    pub unsafe fn GetAttributeIdByUniqueId(&self, unique_id: u32) -> i32 {
        PointCloud_GetAttributeIdByUniqueId(self, unique_id)
    }
    #[inline]
    pub unsafe fn AddAttribute(&mut self, pa: u64) -> ::std::os::raw::c_int {
        PointCloud_AddAttribute(self, pa)
    }
    #[inline]
    pub unsafe fn AddAttribute1(
        &mut self,
        att: *const GeometryAttribute,
        identity_mapping: bool,
        num_attribute_values: ValueType,
    ) -> ::std::os::raw::c_int {
        PointCloud_AddAttribute1(self, att, identity_mapping, num_attribute_values)
    }
    #[inline]
    pub unsafe fn CreateAttribute(
        &self,
        att: *const GeometryAttribute,
        identity_mapping: bool,
        num_attribute_values: ValueType,
    ) -> u64 {
        PointCloud_CreateAttribute(self, att, identity_mapping, num_attribute_values)
    }
    #[inline]
    pub unsafe fn ComputeBoundingBox(&self) -> BoundingBox {
        PointCloud_ComputeBoundingBox(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        PointCloud_PointCloud(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloud12SetAttributeEiSt10unique_ptrINS_14PointAttributeESt14default_deleteIS2_EE"]
    pub fn PointCloud_SetAttribute(
        this: *mut ::std::os::raw::c_void,
        att_id: ::std::os::raw::c_int,
        pa: u64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloud15DeleteAttributeEi"]
    pub fn PointCloud_DeleteAttribute(
        this: *mut ::std::os::raw::c_void,
        att_id: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloud26DeduplicateAttributeValuesEv"]
    pub fn PointCloud_DeduplicateAttributeValues(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloud19DeduplicatePointIdsEv"]
    pub fn PointCloud_DeduplicatePointIds(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco10PointCloud25ApplyPointIdDeduplicationERKNS_15IndexTypeVectorINS_9IndexTypeIjNS_20PointIndex_tag_type_EEES4_EERKSt6vectorIS4_SaIS4_EE"]
    pub fn PointCloud_ApplyPointIdDeduplication(
        this: *mut ::std::os::raw::c_void,
        id_map: *const IndexTypeVector,
        unique_point_ids: *const u8,
    );
}
pub const MeshAttributeElementType_MESH_VERTEX_ATTRIBUTE: MeshAttributeElementType = 0;
pub const MeshAttributeElementType_MESH_CORNER_ATTRIBUTE: MeshAttributeElementType = 1;
pub const MeshAttributeElementType_MESH_FACE_ATTRIBUTE: MeshAttributeElementType = 2;
pub type MeshAttributeElementType = u32;
#[repr(C)]
#[derive(Debug)]
pub struct Mesh {
    pub _base: PointCloud,
    pub attribute_data_: [u64; 3usize],
    pub faces_: IndexTypeVector,
}
pub type Mesh_Face = [u32; 3usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mesh_AttributeData {
    pub element_type: MeshAttributeElementType,
}
#[test]
fn bindgen_test_layout_Mesh_AttributeData() {
    assert_eq!(
        ::std::mem::size_of::<Mesh_AttributeData>(),
        4usize,
        concat!("Size of: ", stringify!(Mesh_AttributeData))
    );
    assert_eq!(
        ::std::mem::align_of::<Mesh_AttributeData>(),
        4usize,
        concat!("Alignment of ", stringify!(Mesh_AttributeData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh_AttributeData>())).element_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh_AttributeData),
            "::",
            stringify!(element_type)
        )
    );
}
impl Default for Mesh_AttributeData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Mesh() {
    assert_eq!(
        ::std::mem::size_of::<Mesh>(),
        216usize,
        concat!("Size of: ", stringify!(Mesh))
    );
    assert_eq!(
        ::std::mem::align_of::<Mesh>(),
        8usize,
        concat!("Alignment of ", stringify!(Mesh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).attribute_data_ as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(attribute_data_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Mesh>())).faces_ as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Mesh),
            "::",
            stringify!(faces_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4MeshC1Ev"]
    pub fn Mesh_Mesh(this: *mut Mesh);
}
impl Default for Mesh {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Mesh {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::uninitialized();
        Mesh_Mesh(&mut __bindgen_tmp);
        __bindgen_tmp
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco4Mesh25ApplyPointIdDeduplicationERKNS_15IndexTypeVectorINS_9IndexTypeIjNS_20PointIndex_tag_type_EEES4_EERKSt6vectorIS4_SaIS4_EE"]
    pub fn Mesh_ApplyPointIdDeduplication(
        this: *mut ::std::os::raw::c_void,
        id_map: *const IndexTypeVector,
        unique_point_ids: *const u8,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct Decoder {
    pub options_: DecoderOptions,
}
#[test]
fn bindgen_test_layout_Decoder() {
    assert_eq!(
        ::std::mem::size_of::<Decoder>(),
        96usize,
        concat!("Size of: ", stringify!(Decoder))
    );
    assert_eq!(
        ::std::mem::align_of::<Decoder>(),
        8usize,
        concat!("Alignment of ", stringify!(Decoder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Decoder>())).options_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Decoder),
            "::",
            stringify!(options_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Decoder22GetEncodedGeometryTypeEPNS_13DecoderBufferE"]
    pub fn Decoder_GetEncodedGeometryType(
        in_buffer: *mut DecoderBuffer,
    ) -> StatusOr<EncodedGeometryType>;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Decoder26DecodePointCloudFromBufferEPNS_13DecoderBufferE"]
    pub fn Decoder_DecodePointCloudFromBuffer(
        this: *mut Decoder,
        in_buffer: *mut DecoderBuffer,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}__ZN5draco7Decoder20DecodeMeshFromBufferEPNS_13DecoderBufferE"]
    pub fn Decoder_DecodeMeshFromBuffer(this: *mut Decoder, in_buffer: *mut DecoderBuffer) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Decoder22DecodeBufferToGeometryEPNS_13DecoderBufferEPNS_10PointCloudE"]
    pub fn Decoder_DecodeBufferToGeometry(
        this: *mut Decoder,
        in_buffer: *mut DecoderBuffer,
        out_geometry: *mut PointCloud,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Decoder22DecodeBufferToGeometryEPNS_13DecoderBufferEPNS_4MeshE"]
    pub fn Decoder_DecodeBufferToGeometry1(
        this: *mut Decoder,
        in_buffer: *mut DecoderBuffer,
        out_geometry: *mut Mesh,
    ) -> Status;
}
extern "C" {
    #[link_name = "\u{1}_ZN5draco7Decoder25SetSkipAttributeTransformENS_17GeometryAttribute4TypeE"]
    pub fn Decoder_SetSkipAttributeTransform(this: *mut Decoder, att_type: GeometryAttribute_Type);
}
impl Default for Decoder {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl Decoder {
    #[inline]
    pub unsafe fn GetEncodedGeometryType(
        in_buffer: *mut DecoderBuffer,
    ) -> StatusOr<EncodedGeometryType> {
        Decoder_GetEncodedGeometryType(in_buffer)
    }
    #[inline]
    pub unsafe fn DecodePointCloudFromBuffer(&mut self, in_buffer: *mut DecoderBuffer) -> u8 {
        Decoder_DecodePointCloudFromBuffer(self, in_buffer)
    }
    #[inline]
    pub unsafe fn DecodeMeshFromBuffer(&mut self, in_buffer: *mut DecoderBuffer) -> u8 {
        Decoder_DecodeMeshFromBuffer(self, in_buffer)
    }
    #[inline]
    pub unsafe fn DecodeBufferToGeometry(
        &mut self,
        in_buffer: *mut DecoderBuffer,
        out_geometry: *mut PointCloud,
    ) -> Status {
        Decoder_DecodeBufferToGeometry(self, in_buffer, out_geometry)
    }
    #[inline]
    pub unsafe fn DecodeBufferToGeometry1(
        &mut self,
        in_buffer: *mut DecoderBuffer,
        out_geometry: *mut Mesh,
    ) -> Status {
        Decoder_DecodeBufferToGeometry1(self, in_buffer, out_geometry)
    }
    #[inline]
    pub unsafe fn SetSkipAttributeTransform(&mut self, att_type: GeometryAttribute_Type) {
        Decoder_SetSkipAttributeTransform(self, att_type)
    }
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_AttributeValueIndex_tag_type__close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_DracoOptions_open0_GeometryAttribute_Type_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<DracoOptions>(),
        96usize,
        concat!(
            "Size of template specialization: ",
            stringify!(DracoOptions)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DracoOptions>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(DracoOptions)
        )
    );
}
pub type ValueType = ::std::os::raw::c_uint;
#[test]
fn __bindgen_test_layout_IndexTypeVector_open0_IndexType_open1_unsigned_int_PointIndex_tag_type__close1_IndexType_open1_unsigned_int_AttributeValueIndex_tag_type__close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<IndexTypeVector>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexTypeVector)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexTypeVector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexTypeVector)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_AttributeValueIndex_tag_type__close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_1()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_2()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_3()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_4()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_5()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_6()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_7()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_8()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_9()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexTypeVector_open0_IndexType_open1_unsigned_int_FaceIndex_tag_type__close1_array_open1_IndexType_open2_unsigned_int_PointIndex_tag_type__close2_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<IndexTypeVector>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexTypeVector)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexTypeVector>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexTypeVector)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_FaceIndex_tag_type__close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
#[test]
fn __bindgen_test_layout_IndexType_open0_unsigned_int_PointIndex_tag_type__close0_instantiation_10()
{
    assert_eq!(
        ::std::mem::size_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Size of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<IndexType<::std::os::raw::c_uint>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(IndexType<::std::os::raw::c_uint>)
        )
    );
}
